
####################################################
# Project: AOP Network Box
# Author: Minju Na
# File: server.R
####################################################

## Load libraries ##
library(shiny)
library(dplyr)
library(httr)
library(jsonlite)
library(reticulate)
library(future)
library(future.apply)
library(DT)
library(shinyjs)
library(shinybusy)

# Setup parallel processing
plan(multisession, workers = parallel::detectCores())
options(future.globals.maxSize = 10 * 1024^3) # 10GB limit

# Load external scripts
source("shared_data.R", local = TRUE)
source("cpu_optimization.R", local = TRUE)

server <- function(input, output, session) {
  
  # --- 1. Reactive Values & State Management ---
  jobRunning <- reactiveVal(FALSE)
  global_data <- reactiveVal(list(go_results = NULL, do_results = NULL))
  execution_state <- reactiveValues(
    trigger_go = NULL, trigger_do = NULL, trigger_aop = NULL,
    selected_smiles = NULL, pval = NULL, selected_score = NULL
  )

  # --- 2. Helper Functions (PubChem API) ---
  smiles_to_cid <- function(smiles) {
    url <- paste0("https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/smiles/", 
                  URLencode(smiles, reserved = TRUE), "/cids/JSON")
    res <- tryCatch(GET(url, timeout(10)), error = function(e) NULL)
    if (!is.null(res) && status_code(res) == 200) {
      data <- fromJSON(content(res, as = "text", encoding = "UTF-8"))
      return(as.integer(data$IdentifierList$CID[1]))
    }
    return(NA_integer_)
  }

  # --- 3. Main Analysis Workflow ---
  observeEvent(input$InputSubmit, {
    req(input$input_smi)
    if (jobRunning()) return()
    
    jobRunning(TRUE)
    disable("InputSubmit")
    show_modal_spinner(text = "Initializing Analysis...")

    # A. SMILES Preprocessing
    raw_smiles <- strsplit(input$input_smi, "[\r\n]+")[[1]] %>% trimws() %>% .[nzchar(.)]
    
    mapping_df <- data.frame(
      SMILES = raw_smiles,
      CID = sapply(raw_smiles, smiles_to_cid),
      stringsAsFactors = FALSE
    )
    save_shared_data("smiles_cid_mapping", mapping_df)

    # B. Python Model Execution (via Reticulate)
    tryCatch({
      use_condaenv("aop", required = TRUE)
      # Prepare input files for Python script
      # (Assuming relative paths for portability)
      py_run_file("scripts/vecnet_final.py")
      
      # Load results generated by Python
      if (file.exists("./Data/table_protein.rda")) {
        load("./Data/table_protein.rda")
        save_shared_data("table_protein", table_protein)
      }
    }, error = function(e) {
      showNotification(paste("Python Error:", e$message), type = "error")
    })

    # C. Biological Module Execution (GO/Pathway/DO/AOP)
    execution_state$selected_smiles <- raw_smiles
    execution_state$pval <- as.numeric(input$selectpval %||% 0.05)
    execution_state$selected_score <- as.numeric(input$selectScore %||% 150) / 1000

    # Parallel Module Triggering
    callModule(proteinServer, "1_Protein", raw_smiles, execution_state$selected_score)
    callModule(pathwayServer, "4_Pathway_mod", raw_smiles, input$selectScore, execution_state$pval)
    
    # Sequential triggers for enrichment
    execution_state$trigger_go <- Sys.time()
    
    remove_modal_spinner()
  })

  # --- 4. Biological Enrichment Observers ---
  
  # GO Analysis
  observeEvent(execution_state$trigger_go, {
    req(execution_state$trigger_go)
    # GO analysis logic using clusterProfiler...
    # After completion, trigger DO analysis
    execution_state$trigger_do <- Sys.time()
  })

  # DO Analysis
  observeEvent(execution_state$trigger_do, {
    req(execution_state$trigger_do)
    # Disease Ontology logic...
    execution_state$trigger_aop <- Sys.time()
  })

  # AOP Analysis
  observeEvent(execution_state$trigger_aop, {
    req(execution_state$trigger_aop)
    callModule(AOPServer, "6_AOP", 
               selected_smiles = execution_state$selected_smiles,
               global_data = global_data)
    
    jobRunning(FALSE)
    enable("InputSubmit")
    showNotification("Analysis Completed Successfully!", type = "message")
  })

  # --- 5. UI Outputs ---
  output$smiles_cid_table <- renderDT({
    mapping <- load_shared_data("smiles_cid_mapping")
    req(mapping)
    datatable(mapping, options = list(dom = 't', paging = FALSE))
  })

  # --- 6. Reset Functionality ---
  observeEvent(input$Reset, {
    updateTextAreaInput(session, "input_smi", value = "")
    jobRunning(FALSE)
    enable("InputSubmit")
  })
}
